#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in1,    gyro,           sensorGyro)
#pragma config(Sensor, in2,    liftPot,        sensorPotentiometer)
#pragma config(Sensor, in3,    clawR,          sensorPotentiometer)
#pragma config(Sensor, in4,    clawL,          sensorPotentiometer)
#pragma config(Sensor, I2C_1,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_2,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port1,           clawL,         tmotorVex393_HBridge, openLoop)
#pragma config(Motor,  port2,           backLeftDrive, tmotorVex393HighSpeed_MC29, openLoop, encoderPort, I2C_2)
#pragma config(Motor,  port3,           backRightDrive, tmotorVex393HighSpeed_MC29, openLoop, reversed, encoderPort, I2C_1)
#pragma config(Motor,  port4,           arm4,          tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port5,           arm2,          tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port6,           frontLeftDrive, tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port7,           arm3,          tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port8,           arm5,          tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port9,           frontRightDrive, tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port10,          clawR,         tmotorVex393_HBridge, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*---------------------------------------------------------------------------*/
/*                                                                           */
/*        Description: Competition template for VEX EDR                      */
/*                                                                           */
/*---------------------------------------------------------------------------*/

// This code is for the VEX cortex platform
#pragma platform(VEX2)

// Select Download method as "competition"
#pragma competitionControl(Competition)

//Main competition background code...do not modify!
#include "Vex_Competition_Includes.c"
#include "563 Functions V2.c"
#include "563 Autons V2.c"

const short leftButton = 1;
const short centerButton = 2;
const short rightButton = 4;

////////////////////////////LCD AUTON SELECTION////////////////////////////////////////////
#define AUTON_CHOICE_WAIT_TIME 5000  // 5 seconds = 5000 ms
void waitForPress()
{
	while(nLCDButtons == 0 && time1[T1] < AUTON_CHOICE_WAIT_TIME){}
	wait1Msec(5);
}
void waitForRelease()
{
	while(nLCDButtons != 0 && time1[T1] < AUTON_CHOICE_WAIT_TIME){}
	wait1Msec(5);
	clearTimer(T1);
}
//////////////////////////////////////////////////////////////////////////////////////////
#ifndef NUMBER_OF_AUTONS
	#define NUMBER_OF_AUTONS 0
#endif
int count = 0;
const int maxCount = NUMBER_OF_AUTONS + 1;

/*---------------------------------------------------------------------------*/
/*                          Pre-Autonomous Functions                         */
/*                                                                           */
/*  You may want to perform some actions before the competition starts.      */
/*  Do them in the following function.  You must return from this function   */
/*  or the autonomous and usercontrol tasks will not be started.  This       */
/*  function is only called once after the cortex has been powered on and    */
/*  not every time that the robot is disabled.                               */
/*---------------------------------------------------------------------------*/

void pre_auton()
{
bLCDBacklight =true;
	//Completely clear out any previous sensor readings by setting the port to "sensorNone"
	//Clear LCD
	clearLCDLine(0);
	clearLCDLine(1);

	// Set timer

	clearTimer(T1);

	//Loop while center button is not pressed & less than defined wait time
	while(nLCDButtons != centerButton && time1[T1] < AUTON_CHOICE_WAIT_TIME)
	{
		//Switch case that allows the user to choose from 4 different options
		switch(count){
		case 0:
			//Display the choice to do nothing
			displayLCDCenteredString(0, "Nope.");
			displayLCDCenteredString(1, "<    Enter    >");
			/* Do button stuff for the START */ waitForPress(); if(nLCDButtons == leftButton) { waitForRelease(); count = NUMBER_OF_AUTONS;} else if(nLCDButtons == rightButton) { waitForRelease(); count++;}
			break;
		case 1:
			//Display 1st choice
			displayLCDCenteredString(0, autonOneName);
			displayLCDCenteredString(1, "<    Enter    >");
			/* Do button stuff */ waitForPress(); if(nLCDButtons == leftButton) { waitForRelease(); count--; } else if(nLCDButtons == rightButton) { waitForRelease(); count++; }
			break;
		case 2:
			//Display 2nd choice
			displayLCDCenteredString(0, autonTwoName);
			displayLCDCenteredString(1, "<    Enter    >");
			/* Do button stuff */ waitForPress(); if(nLCDButtons == leftButton) { waitForRelease(); count--; } else if(nLCDButtons == rightButton) { waitForRelease(); count++; }
			break;
		case 3:
			//Display 3rd choice
			displayLCDCenteredString(0, autonThreeName);
			displayLCDCenteredString(1, "<    Enter    >");
			/* Do button stuff */ waitForPress(); if(nLCDButtons == leftButton) { waitForRelease(); count--; } else if(nLCDButtons == rightButton) { waitForRelease(); count++; }
			break;
		case 4:
			//Display 4th choice
			displayLCDCenteredString(0, autonFourName);
			displayLCDCenteredString(1, "<    Enter    >");
			/* Do button stuff */ waitForPress(); if(nLCDButtons == leftButton) { waitForRelease(); count--; } else if(nLCDButtons == rightButton) { waitForRelease(); count++; }
			break;
		case 5:
			//Display 5th choice
			displayLCDCenteredString(0, autonFiveName);
			displayLCDCenteredString(1, "<    Enter    >");
			/* Do button stuff */ waitForPress(); if(nLCDButtons == leftButton) { waitForRelease(); count--; } else if(nLCDButtons == rightButton) { waitForRelease(); count++; }
			break;
		case 6:
			//Display 6th choice
			displayLCDCenteredString(0, autonSixName);
			displayLCDCenteredString(1, "<    Enter    >");
			/* Do button stuff */ waitForPress(); if(nLCDButtons == leftButton) { waitForRelease(); count--; } else if(nLCDButtons == rightButton) { waitForRelease(); count++; }
			break;
		case 7:
			//Display 6th choice
			displayLCDCenteredString(0, autonSevenName);
			displayLCDCenteredString(1, "<    Enter    >");
			/* Do button stuff */ waitForPress(); if(nLCDButtons == leftButton) { waitForRelease(); count--; } else if(nLCDButtons == rightButton) { waitForRelease(); count++; }
			break;
		case maxCount:
		default:
			count = 0;
			break;
		}
	}
  bStopTasksBetweenModes = true;


}

/*---------------------------------------------------------------------------*/
/*                                                                           */
/*                              Autonomous Task                              */
/*                                                                           */
/*  This task is used to control your robot during the autonomous phase of   */
/*  a VEX Competition.                                                       */
/*                                                                           */
/*  You must modify the code to add your own robot specific commands here.   */
/*---------------------------------------------------------------------------*/

task autonomous()
{
	//Clear LCD
	clearLCDLine(0);
	clearLCDLine(1);
	//Switch Case that actually runs the user choice
	switch(count){
	case 0:
		//If count = 0, run the code correspoinding with doing nothing
		displayLCDCenteredString(0, "No autonomous");
		displayLCDCenteredString(1, "is running.");
		break;
	case 1:
		//If count = 1, run the code correspoinding with choice 1
		displayLCDCenteredString(0, autonOneName);
		displayLCDCenteredString(1, "is running!");
		// Auton 1//////////////////////////////////////////////////////////////////////////////////
		autoOne();
		// Auton 1//////////////////////////////////////////////////////////////////////////////////

		break;
	case 2:
		//If count = 2, run the code correspoinding with choice 2
		displayLCDCenteredString(0, autonTwoName);
		displayLCDCenteredString(1, "is running!");
		// Auton 2 ////////////////////////////////////////////////////////////////////////////////
		autoTwo();
		// Auton 2 ////////////////////////////////////////////////////////////////////////////////
		break;
	case 3:
		//If count = 3, run the code correspoinding with choice 3
		displayLCDCenteredString(0, autonThreeName);
		displayLCDCenteredString(1, "is running!");
		// Auton 3 ////////////////////////////////////////////////////////////////////////////////
		autoThree();
		// Auton 3 ////////////////////////////////////////////////////////////////////////////////
		break;
	case 4:
		//If count = 4, run the code correspoinding with choice 4
		displayLCDCenteredString(0, autonFourName);
		displayLCDCenteredString(1, "is running!");
		// Auton 4 ////////////////////////////////////////////////////////////////////////////////
		autoFour();
		// Auton 4 ////////////////////////////////////////////////////////////////////////////////
		break;
	case 5:
		//If count = 5, run the code correspoinding with choice 5
		displayLCDCenteredString(0, autonFiveName);
		displayLCDCenteredString(1, "is running!");
		// Auton 5 ////////////////////////////////////////////////////////////////////////////////
		autoFive();
		// Auton 5 ////////////////////////////////////////////////////////////////////////////////
		break;
	case 6:
		//If count = 6, run the code correspoinding with choice 6
		displayLCDCenteredString(0, autonSixName);
		displayLCDCenteredString(1, "is running!");
		// Auton 6 ////////////////////////////////////////////////////////////////////////////////
		autoSix();
		// Auton 5 ////////////////////////////////////////////////////////////////////////////////
		break;
	case 7:
		//If count = 7, run the code correspoinding with choice 7
		displayLCDCenteredString(0, autonSevenName);
		displayLCDCenteredString(1, "is running!");
		// Auton 7 ////////////////////////////////////////////////////////////////////////////////
		autoSeven();
		// Auton 7 ////////////////////////////////////////////////////////////////////////////////
		break;
	case maxCount:
	default:
		displayLCDCenteredString(0, "No valid choice");
		displayLCDCenteredString(1, "was made!");
		break;
		//------------- End of Robot Movement Code -----------------------
	}
}


/*---------------------------------------------------------------------------*/
/*                                                                           */
/*                              User Control Task                            */
/*                                                                           */
/*  This task is used to control your robot during the user control phase of */
/*  a VEX Competition.                                                       */
/*                                                                           */
/*  You must modify the code to add your own robot specific commands here.   */
/*---------------------------------------------------------------------------*/

task usercontrol()
{
	iDes = (SensorValue [in3]);
  while (true)
  {
			//startTask (clawControll);
			startTask (claw);
			drive();

		while(vexRT[Btn6U])
		{
			drive();
			lift(127);
		}
		liftStall(10);


		while(vexRT[Btn6D])
		{
			drive();
			lift(-50);
		}

		while(vexRT[Btn7D])
		{
			drive();
			lift(-127);
		}

		while(vexRT[Btn8U])
		{
			drive();
			while (vexRT[Btn6U])
			{
				lift(127);
			}
		}
		while(vexRT[Btn5D])
		{
			drive();

		}
  }
}
